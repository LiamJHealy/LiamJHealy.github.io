I"\<p>lambda expression can be understood as an anonymous function, it doesn’t need a name, it is created in runtime:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam1</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[]()</span>
<span style="color: #93a1a1">{</span>
  <span style="color: #586e75">cout</span><span style="color: #93a1a1">&lt;&lt;</span><span style="color: #859900">"Hello World!"</span><span style="color: #93a1a1">;</span>
<span style="color: #93a1a1">};</span>
<span style="color: #586e75">lam1</span><span style="color: #93a1a1">();</span>
</code></pre></div></div>

<p>The code above shows a simplest lambda expression, when <strong><em>lam1()</em></strong> is called, it will print “Hello World!”.</p>

<h3 id="how-is-the-lambda-expression-existed-in-c"><strong><center>How is the lambda expression existed in C++?</center></strong></h3>

<p>It is existed a <strong><em>closure class</em></strong>, each lambda is a unique closer class generated by the compiler in runtime. So <strong><em>it is a object and can be copied</em></strong>:</p>

<!-- more -->

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam1_1</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam1</span><span style="color: #93a1a1">;</span>
<span style="color: #586e75">lam1_1</span><span style="color: #93a1a1">();</span>
</code></pre></div></div>

<p>when lam1_1 is called, it will also print “Hello World!”. Lambda turns the functions to be objects.</p>

<h3 id="how-to-form-a-lambda"><strong><center>How to form a lambda</center></strong></h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap2</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">,</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span>
<span style="color: #93a1a1">{</span>
  <span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">result</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam</span><span style="color: #93a1a1">(</span><span style="color: #859900">4</span><span style="color: #93a1a1">);</span><span style="color: #657b83">//result will be 12</span>
</code></pre></div></div>

<p>Take the above code block as an example:</p>

<h4 id="capture-list"><center>Capture List</center></h4>

<p>1, Inside the [ ] is the so called “<strong>capture list</strong>”</p>

<p>​	capture list is used to “capture” the variables in the current local scope, the first one in the capture list can be used as “<strong>default captured variable</strong>”. But <strong>the capture variables from the 2nd must be explicitly defined.</strong></p>

<p>​	So in the above example, the first captured variable will be cap1, because we defined cap2 as a captured variable explicitly and at the same time we used cap1 in lambda, then of cause cap1 will be considered as the first/default captured variable.</p>

<p>​	If we defined all captured variables explicitly, which is preferred, we can not use the variables which are not defined as captured variable any more:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap2</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap3</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">4</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #586e75">cap1</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap2</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span>
<span style="color: #93a1a1">{</span>
  <span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Wrong!</span>
</code></pre></div></div>

<p>​	The above code block is wrong, it can not even be compiled, because cap3 is not captured by lambda <strong><em>lam</em></strong>. So in order to capture cap3, you can either leave the 1st position to be default captured variable or define it explicitly:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">,</span><span style="color: #586e75">cap1</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap2</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span>
<span style="color: #93a1a1">{</span>
  <span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Correct!</span>

<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap2</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span>
<span style="color: #93a1a1">{</span>
  <span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Correct!</span>
</code></pre></div></div>

<p>​	What’s more, <strong>leaving the 1st postion to be default captured variable can capture more than one variables!</strong>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap2</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap3</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">4</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap4</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">5</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">,</span> <span style="color: #586e75">cap2</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span> 
<span style="color: #93a1a1">{</span>
	<span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap4</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Correct!</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">result</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam</span><span style="color: #93a1a1">(</span><span style="color: #859900">6</span><span style="color: #93a1a1">);</span>
</code></pre></div></div>

<p>​	The above code block is completly correct! You can see that cap3 and cap4 are not defined explicitly, but they are all correctly captured. Which means we can do the following for conveniency:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap2</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap3</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">4</span><span style="color: #93a1a1">;</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">cap4</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">5</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span> 
<span style="color: #93a1a1">{</span>
	<span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap2</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap3</span><span style="color: #93a1a1">*</span><span style="color: #586e75">cap4</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Correct!</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">result</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam</span><span style="color: #93a1a1">(</span><span style="color: #859900">6</span><span style="color: #93a1a1">);</span>
</code></pre></div></div>

<p>​	<strong>By doing this, the lambda can capture as many variables as you like~</strong></p>

<p>​	Capturring variables is just like passing intput arguments, <strong>&amp; means capture by reference and = means capture by value:</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span> 
<span style="color: #93a1a1">{</span>
	<span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">5</span><span style="color: #93a1a1">;</span>
	<span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Capture by reference</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">result</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam</span><span style="color: #93a1a1">(</span><span style="color: #859900">6</span><span style="color: #93a1a1">);</span>
</code></pre></div></div>

<p>​	<strong>If capturing by refrence ( use [&amp;] ), the result will be 30 and cap1 will be 5 after the lambda is called</strong>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">1</span><span style="color: #93a1a1">;</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[</span><span style="color: #93a1a1">=</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">arg</span><span style="color: #93a1a1">)</span> 
<span style="color: #93a1a1">{</span>
	<span style="color: #586e75">cap1</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">5</span><span style="color: #93a1a1">;</span>
	<span style="color: #6c71c4">return</span> <span style="color: #586e75">cap1</span><span style="color: #93a1a1">*</span><span style="color: #586e75">arg</span><span style="color: #93a1a1">;</span> 
<span style="color: #93a1a1">};</span><span style="color: #657b83">//Wrong, cap1 can not be changed</span>
<span style="color: #cb4b16">int</span> <span style="color: #586e75">result</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam</span><span style="color: #93a1a1">(</span><span style="color: #859900">6</span><span style="color: #93a1a1">);</span>
</code></pre></div></div>

<p>​	<strong>If capturing by value  ( use [=] ), you can not change the captured variable inside the lambda, so the above code block is wrong and it can not be compiled.</strong></p>

<p>​	<strong>Attention!Capturing variables by reference should be avoided</strong>, because inside the lambda you don’t know if the captured variable is changed outside, the lambda is acturally sharing the same memory block with the other parts of the program.</p>

<h4 id="arguments-list"><center>Arguments List</center></h4>

<p>Lambda supports auto as input arguments! The type will be deducted, this is the so called generic Lambda:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam6</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[](</span><span style="color: #6c71c4">auto</span> <span style="color: #586e75">arg1</span><span style="color: #93a1a1">,</span> <span style="color: #6c71c4">auto</span> <span style="color: #586e75">arg2</span><span style="color: #93a1a1">)</span> <span style="color: #93a1a1">{</span><span style="color: #6c71c4">return</span> <span style="color: #586e75">arg1</span> <span style="color: #93a1a1">*</span> <span style="color: #586e75">arg2</span><span style="color: #93a1a1">;</span> <span style="color: #93a1a1">};</span>
<span style="color: #cb4b16">double</span> <span style="color: #586e75">r6</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">lam6</span><span style="color: #93a1a1">(</span><span style="color: #859900">2U</span><span style="color: #93a1a1">,</span> <span style="color: #859900">1.2</span><span style="color: #586e75">f</span><span style="color: #93a1a1">);</span>
</code></pre></div></div>

<h4 id="why-do-we-need-capture-list"><center>Why do we need capture list?</center></h4>

<p>Now we know that one big difference between normal function and lambda is that lambda has “capture list”. But why do we need capture list when we already get argument list?</p>

<p>One of the main reasons(actually I only know this…) is when lambda will be called by some others, its interface(input aruguments) is fixed, then you can not add more arguments, which means if you want to pass additional variables, you can only use capture list:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #cb4b16">int</span> <span style="color: #586e75">comp</span> <span style="color: #93a1a1">=</span> <span style="color: #859900">4</span><span style="color: #93a1a1">;</span>
<span style="color: #586e75">vector</span><span style="color: #93a1a1">&lt;</span><span style="color: #cb4b16">int</span><span style="color: #93a1a1">&gt;</span> <span style="color: #586e75">values</span><span style="color: #93a1a1">{</span> <span style="color: #859900">1</span><span style="color: #93a1a1">,</span> <span style="color: #859900">2</span><span style="color: #93a1a1">,</span> <span style="color: #859900">3</span><span style="color: #93a1a1">,</span> <span style="color: #859900">4</span><span style="color: #93a1a1">,</span> <span style="color: #859900">5</span> <span style="color: #93a1a1">};</span>
<span style="color: #6c71c4">auto</span> <span style="color: #586e75">item</span> <span style="color: #93a1a1">=</span> <span style="color: #586e75">find_if</span><span style="color: #93a1a1">(</span><span style="color: #586e75">values</span><span style="color: #93a1a1">.</span><span style="color: #586e75">begin</span><span style="color: #93a1a1">(),</span> <span style="color: #586e75">values</span><span style="color: #93a1a1">.</span><span style="color: #586e75">end</span><span style="color: #93a1a1">(),</span> 
	<span style="color: #93a1a1">[</span><span style="color: #93a1a1">&amp;</span><span style="color: #93a1a1">](</span><span style="color: #cb4b16">int</span> <span style="color: #586e75">value</span><span style="color: #93a1a1">)</span>
	<span style="color: #93a1a1">{</span><span style="color: #657b83">//the input argument int const&amp; value is occupied by the STL function</span>
		<span style="color: #6c71c4">return</span> <span style="color: #586e75">value</span> <span style="color: #93a1a1">==</span> <span style="color: #586e75">comp</span><span style="color: #93a1a1">;</span> 
	<span style="color: #93a1a1">}</span>
<span style="color: #93a1a1">);</span>
</code></pre></div></div>

<p>The above code block shows a example when capture list is a must. We want to find the vector iterator whose value is equal to variable <strong>comp</strong>. In order to do this, we use the <strong>find_if</strong> STL function in <algorithm>.</algorithm></p>

<p>The <strong>find_if</strong> function asks for the 3rd input argument to be a predicate, and <strong>it already defined the form of this predicate</strong>(can be a function or a lambda):</p>

<p>1 It has only one input argument, its type must be the same as the vector’s element.</p>

<p>2 It must return a boolean.</p>

<p>The find_if function will then return the iterator whose value can make the returned boolean to be true.</p>

<p>Now we use lambda as the predicate, then its argument list is fixed:</p>

<p>​	<strong>it must be</strong> <strong><em>(int value)</em></strong>, if you define it to be (int value, int comp), it’s wrong.</p>

<p><strong>So what if we want to use the variable <em>comp</em> in this lambda? Only one solution:we capture comp through the capture list.</strong></p>

<h4 id="explicitly-defining-returned-type"><strong><center>Explicitly defining returned type</center></strong></h4>

<p>Another difference between lambda and a normal function is the returned type, if you noticed, the lambda expression doesn’t need a returned type.</p>

<p>Yes, the lambda will return a deducted type, for example:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[](){</span><span style="color: #6c71c4">return</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;};</span>
<span style="color: #586e75">lam</span><span style="color: #93a1a1">();</span><span style="color: #657b83">//return an int</span>
</code></pre></div></div>

<p>in the above code block, lam() will return an int. This int is deducted by lambda.</p>

<p>What if we want a exact type? It is still possible:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span style="color: #6c71c4">auto</span> <span style="color: #586e75">lam</span> <span style="color: #93a1a1">=</span> <span style="color: #93a1a1">[]()</span><span style="color: #93a1a1">-&gt;</span><span style="color: #cb4b16">double</span><span style="color: #93a1a1">{</span><span style="color: #6c71c4">return</span> <span style="color: #859900">3</span><span style="color: #93a1a1">;};</span>
<span style="color: #586e75">lam</span><span style="color: #93a1a1">();</span><span style="color: #657b83">//return an double</span>
</code></pre></div></div>

<p>add <strong>”-&gt;double”</strong> after the arguments, you can define the returned type to be double.</p>

:ET